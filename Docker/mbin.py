#! /usr/bin/env python3
#Author: njvarghese|2022-23
import os, sys, re
import argparse, subprocess, shutil
from Bio import SeqIO

import mbin_metabat, logfile
import mbin_sdb, mbin_lineage, mbin_metadata
import mbin_filterbins, mbin_qassn

def qc(files):
  for eachfile in files:
    if not os.path.isfile(eachfile):
      log.info("File: " + str(eachfile) + " :does not exist. Fatal error.")
      exit()

def move_bins(bins_dir):
 odir = os.getcwd()
 numbins = 0
 unbinned = None
 for efn in os.listdir(odir):
  fpath = odir+'/'+efn
  if os.path.isfile(fpath):
   if efn == 'bins.unbinned.fa' : unbinned = fpath
   elif re.match(r'bins\.\d+\.fa',efn):
    subprocess.check_call(['mv',fpath, bins_dir])
    numbins += 1

 if numbins > 1 : pass
 else: return(numbins)

 #Move unbinned contigs of size >=500000 bp to their own bin
 if unbinned and os.path.isfile(unbinned):
  for record in SeqIO.parse(unbinned, "fasta"):
   if (len(record.seq) > 500000) :
   #write to their own bin
    numbins += 1
    new_fn = bins_dir + '/bins.' + str(numbins) + '.fa'
    log.info('New bin:' + new_fn + '\n')
    sys.stderr.write('New bin:' + new_fn + '\n')
    wh = open(new_fn,'w')
    wh.write('>' + str(record.id) + '\n' + str(record.seq) + '\n')
    wh.close()

 return(numbins)

def run(contigs, bam, mapfn, gff, lineage_sdb, lineage_tsv, numcores, pplacer_cores, combined, sortfna, sortaln):

 #check for required files
 checkfiles = [contigs, gff]
 if lineage_sdb: checkfiles.append(lineage_sdb)
 if lineage_tsv: checkfiles.append(lineage_tsv)
 if mapfn : checkfiles.append(mapfn)
 #check if directory provided
 if combined == "yes": 
  if not os.path.isdir(bam): 
    log.info("Directory:" + str(bam) + " :does not exist. Fatal error.")
    exit()
 elif combined == "no":
  checkfiles.append(bam)
 qc(checkfiles)

 #predefined variables
 sdb_name = 'mbin.sdb'
 bins_dir = 'metabat-bins'
 filtered_bins_dir = 'filtered-metabat-bins'
 hqmq_bins_dir = 'hqmq-metabat-bins'
 checkm_dir= 'checkm-out'
 checkm_qa_out = 'checkm-qa.out'
 gtdbtk_dir = 'gtdbtk-output'

 #flag file post completion
 no_load_fn = 'mbin.nobins'
 complete_fn = 'mbin.success'

 #run metabat
 log.info('..run metabat')
 mbin_metabat.internal(contigs, mapfn, bam, log, numcores, combined, sortfna, sortaln)

 #check metabat bins and move bin files to new directory
 log.info('..move bins')
 if not os.path.isdir(bins_dir) : os.mkdir(bins_dir)
 num_bins = move_bins(bins_dir)

 if num_bins >= 1 : pass
 else:
  #touch file to avoid pickup
  subprocess.check_call(['touch',no_load_fn])
  log.info('No bins generated by metabat.Created flag file to avoid pickup: '+ no_load_fn)
  subprocess.check_call(['touch', complete_fn])
  log.info('Completion flag file: ' + complete_fn)
  exit()

 #create sqlitedb
 log.info('..creating sdb')
 mbin_sdb.createsdb(sdb_name, log)

 #write bin informatin from bins_dir to sdb 
 log.info('..add bins to sdb')
 mbin_sdb.writebins(sdb_name,bins_dir)

 #optional for NMDC 
 if (lineage_sdb or lineage_tsv):
  #query scaffold lineage
  log.info('..query per scaffold lineage')
  if lineage_sdb: mbin_metadata.query_slineage(sdb_name, lineage_sdb, log)
  elif lineage_tsv: mbin_metadata.query_slineage_tsv(sdb_name, lineage_tsv, log)

  #filter bins to remove any scaffolds that match another domain
  log.info('..filter bins based on domain information')
  if not os.path.isdir(filtered_bins_dir): os.mkdir(filtered_bins_dir)
  mbin_filterbins.run(sdb_name, bins_dir, filtered_bins_dir, log)

 else:
  filtered_bins_dir = bins_dir

 #get scaff info
 log.info('..get per scaffold metadata') 
 mbin_metadata.parse_annotation(sdb_name,gff, log)

 #get rRNA and tRNA count per bin
 log.info('..get bin metadata from scaffold metadata')
 mbin_metadata.query_bin_metadata(sdb_name)

 #run checkm
 log.info('..run checkm')
 mbin_lineage.checkm(filtered_bins_dir, checkm_dir, checkm_qa_out, numcores, pplacer_cores)

 #mimag based hq,mq,lq assignment & move hq+mq to sep dir
 log.info('..assign quality and move hq+mq')
 if not os.path.isdir(hqmq_bins_dir): subprocess.check_call(['mkdir',hqmq_bins_dir])

 num_hqmq = mbin_qassn.run(checkm_qa_out, filtered_bins_dir, hqmq_bins_dir, sdb_name, log)

 if num_hqmq >=1 :

  #optional for NMDC
  if(lineage_sdb or lineage_tsv):
   #img phylodist
   log.info('..run img phylodist on hq,mq bins')
   if lineage_sdb : mbin_lineage.phylodist(lineage_sdb, hqmq_bins_dir, sdb_name, log)
   elif lineage_tsv : mbin_lineage.phylodist_tsv(lineage_tsv, hqmq_bins_dir, sdb_name, log)
  
  #gtdb-tk lineage
  log.info('..run gtdb-tk on hq,mq bins')
  mbin_lineage.gtdbtk(hqmq_bins_dir, gtdbtk_dir, sdb_name, numcores, pplacer_cores, log)

  #added for cromwell : tar hqmq bins dir
  log.info('..compressing hqmq bins dir')
  shutil.make_archive(hqmq_bins_dir, 'gztar',root_dir=os.getcwd(),base_dir=os.path.basename(hqmq_bins_dir))
 
 else:
  #touch file to avoid pickup
  subprocess.check_call(['touch',no_load_fn])  
  log.info('No HQ/MQ bins. Created flag file to avoid pickup:'+ no_load_fn)

 #added for cromwell : tar filtered metatbat bins dir
 #required to retain LQ bins for downstream EBIP pipeline
 log.info('..compressing filtered/non-filtered metabat bins dir')
 shutil.make_archive(filtered_bins_dir, 'gztar',root_dir=os.getcwd(),base_dir=os.path.basename(filtered_bins_dir))

 #write flag file
 subprocess.check_call(['touch', complete_fn])
 log.info('Completion flag file:' + complete_fn)

if __name__ == '__main__':
 parser = argparse.ArgumentParser(
  prog= "mbin.py" ,
  description='Metagenome binning pipeline for IMG', 
  epilog="REQUIRED: ENVS must be provided : GTDBTK_DATA_PATH=<path> and CHECKM_DATA_PATH=<path>")
 
 parser.add_argument("--threads", type=int, default=1,  help = "Num of threads/cores (default:1)")
 parser.add_argument("--pthreads", type=int, default=1,  help = "Number of pplacer threads (default:1)")
 parser.add_argument("--combined", type=str, default= "no",  help = "(yes/no) that a mutli sam dir was provided as --aln argument (default:no)")
 parser.add_argument("--sortfna", type=str, default="no", help = "(yes/no) Sort provided contigs file (default: no, always no for combined)")
 parser.add_argument("--sortaln", type=str, default="no", help = "(yes/no) Sort provided alignment file using samtools (default: no, always no for combined)")
 #optional for NMDC
 parser.add_argument("--map", type=str, help= "MAP file containing mapping of contig headers between SAM and FNA (will skip contig name mapping if absent)")
 parser.add_argument("--lin", type=str, help = "IMG lineage SQLITE DB for taxon (if tsv OR sdb are not provided, filtering and bin lineage prediction will be skipped)")
 parser.add_argument("--lintsv", type=str, help = "IMG lineage TSV file taxon (if tsv OR sdb are not provided, filtering and bin lineage prediction will be skipped)")

 requiredNamed = parser.add_argument_group('Required named arguments')
 requiredNamed.add_argument("-f", "--fna", type=str, help= "Contigs fasta file", required=True)
 requiredNamed.add_argument("-a", "--aln", type=str, help= "Metagenome alignment file in BAM/SAM format", required=True)
 requiredNamed.add_argument("-g", "--gff", type=str, help = "GFF file from IMG annotation pipeline",required=True)
 
 args = parser.parse_args()
 log = logfile.startlog('mbin-docker')
 run(args.fna, args.aln, args.map, args.gff, args.lin, args.lintsv, args.threads, args.pthreads, args.combined, args.sortfna, args.sortaln)
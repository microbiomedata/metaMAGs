#! /usr/bin/env python3
#Author: njvarghese|2022-24
#v1.0
import os, sys, re
import argparse, subprocess, shutil
from Bio import SeqIO

import mbin_metabat, logfile
import mbin_sdb, mbin_lineage, mbin_metadata
import mbin_filterbins, mbin_qassn, mbin_ebip

def qc(files, dirs):
  for eachfile in files:
    if not os.path.isfile(eachfile):
      log.info("File: " + str(eachfile) + " :does not exist. Fatal error.")
      exit()
  
  for eachdir in dirs:
   if not os.path.isdir(eachdir):
    log.info("Dir: " + str(eachdir) + " : does not exist. Fatal error.")
    exit()

def move_bins(bins_dir):
 odir = os.getcwd()
 numbins = 0
 unbinned = None
 for efn in os.listdir(odir):
  fpath = odir+'/'+efn
  if os.path.isfile(fpath):
   if efn == 'bins.unbinned.fa' : unbinned = fpath
   elif re.match(r'bins\.\d+\.fa',efn):
    subprocess.check_call(['mv',fpath, bins_dir])
    numbins += 1

 if numbins > 1 : pass
 else: return(numbins)

 #Move unbinned contigs of size >=500000 bp to their own bin
 if unbinned and os.path.isfile(unbinned):
  for record in SeqIO.parse(unbinned, "fasta"):
   if (len(record.seq) > 500000) :
   #write to their own bin
    numbins += 1
    new_fn = bins_dir + '/bins.' + str(numbins) + '.fa'
    log.info('New bin:' + new_fn + '\n')
    sys.stderr.write('New bin:' + new_fn + '\n')
    wh = open(new_fn,'w')
    wh.write('>' + str(record.id) + '\n' + str(record.seq) + '\n')
    wh.close()

 return(numbins)

def run(contigs, bam, mapfn, gff, lineage_sdb, lineage_tsv, numcores, pplacer_cores, combined, sortfna, sortaln, checkpoint, eukcc_db):

 #check for required files
 checkfiles = [contigs, gff]
 checkdirs = []
 if lineage_sdb: checkfiles.append(lineage_sdb)
 if lineage_tsv: checkfiles.append(lineage_tsv)
 if mapfn : checkfiles.append(mapfn)
 if eukcc_db : 
  checkdirs.append(eukcc_db)
  ncbi_db = eukcc_db + '/etetoolkit/taxa.sqlite'
  checkfiles.append(ncbi_db)

 if combined == "yes": 
  checkdirs.append(bam)
 elif combined == "no":
  checkfiles.append(bam)

 qc(checkfiles, checkdirs)

 #predefined variables
 sdb_name = 'mbin.sdb'
 bins_dir = 'metabat-bins'
 filtered_bins_dir = 'filtered-metabat-bins'
 hqmq_bins_dir = 'hqmq-metabat-bins'
 checkm_dir= 'checkm-out'
 checkm_qa_out = 'checkm-qa.out'
 gtdbtk_dir = 'gtdbtk-output'

 #flag file post completion
 no_load_fn = 'mbin.nobins'
 complete_fn = 'mbin.success'

 #flag files for checkpointing
 metabat_complete = "checkpnt.metabat"
 sdb_complete = "checkpnt.sdb"
 linmeta_complete = "checkpnt.linmeta"
 scafmeta_complete = "checkpnt.scafmeta"
 binmeta_complete = "checkpnt.binmeta"
 checkm_complete = "checkpnt.checkm"
 mimag_complete = "checkpnt.mimag"
 phylodist_complete = "checkpnt.phylodist"
 gtdbtk_complete = "checkpnt.gtdbtk"
 eukcc_complete = "checkpnt.eukcc"

 #run metabat
 if (checkpoint == "yes") and os.path.isfile(metabat_complete): pass
 else:
  log.info('..run metabat')
  mbin_metabat.internal(contigs, mapfn, bam, log, numcores, combined, sortfna, sortaln)

  #check metabat bins and move bin files to new directory
  log.info('..move bins')
  if not os.path.isdir(bins_dir) : os.mkdir(bins_dir)
  num_bins = move_bins(bins_dir)

  #add checkpoint file
  if (checkpoint == "yes") : subprocess.check_call(['touch',metabat_complete])

  if num_bins >= 1 : pass
  else:
   #touch file to avoid pickup
   subprocess.check_call(['touch',no_load_fn])
   log.info('No bins generated by metabat.Created flag file to avoid pickup: '+ no_load_fn)
   subprocess.check_call(['touch', complete_fn])
   log.info('Completion flag file: ' + complete_fn)
   exit()

 if (checkpoint == "yes") and os.path.isfile(sdb_complete): pass
 else:
  #create sqlitedb
  log.info('..creating sdb')
  mbin_sdb.createsdb(sdb_name, log)

  #write bin informatin from bins_dir to sdb 
  log.info('..add bins to sdb')
  mbin_sdb.writebins(sdb_name,bins_dir)
  mbin_sdb.createindex(sdb_name)
  
  #add checkpoint file
  if (checkpoint == "yes") : subprocess.check_call(['touch',sdb_complete])

 #optional for NMDC 
 if (lineage_sdb or lineage_tsv):
  if (checkpoint == "yes") and os.path.isfile(linmeta_complete): pass
  else:
   #query scaffold lineage
   log.info('..query per scaffold lineage')
   if lineage_sdb: mbin_metadata.query_slineage(sdb_name, lineage_sdb, log)
   elif lineage_tsv: mbin_metadata.query_slineage_tsv(sdb_name, lineage_tsv, log)

   #filter bins to remove any scaffolds that match another domain
   log.info('..filter bins based on domain information')
   if not os.path.isdir(filtered_bins_dir): os.mkdir(filtered_bins_dir)
   mbin_filterbins.run(sdb_name, bins_dir, filtered_bins_dir, log)

   #add checkpoint file
   if (checkpoint == "yes") : subprocess.check_call(['touch',linmeta_complete])

 else:
  filtered_bins_dir = bins_dir

 #get scaff info
 if (checkpoint == "yes") and os.path.isfile(scafmeta_complete): pass
 else:
  log.info('..get per scaffold metadata') 
  mbin_metadata.parse_annotation(sdb_name,gff, log)
  #add checkpoint file
  if (checkpoint == "yes") : subprocess.check_call(['touch',scafmeta_complete])

 #get rRNA and tRNA count per bin
 if (checkpoint == "yes") and os.path.isfile(binmeta_complete): pass
 else:
  log.info('..get bin metadata from scaffold metadata')
  mbin_metadata.query_bin_metadata(sdb_name)
  #add checkpoint file
  if (checkpoint == "yes") : subprocess.check_call(['touch',binmeta_complete])

 #run checkm
 if (checkpoint == "yes") and os.path.isfile(checkm_complete): pass
 else:
  log.info('..run checkm')
  mbin_lineage.checkm(filtered_bins_dir, checkm_dir, checkm_qa_out, numcores, pplacer_cores)
  #add checkpoint file
  if (checkpoint == "yes") : subprocess.check_call(['touch',checkm_complete])

 #mimag based hq,mq,lq assignment & move hq+mq to sep dir
 if (checkpoint == "yes") and os.path.isfile(mimag_complete): pass
 else:
  log.info('..assign quality and move hq+mq')
  if not os.path.isdir(hqmq_bins_dir): subprocess.check_call(['mkdir',hqmq_bins_dir])
  mbin_qassn.run(checkm_qa_out, filtered_bins_dir, hqmq_bins_dir, sdb_name, log)

  #add checkpoint file
  if (checkpoint == "yes") : subprocess.check_call(['touch',mimag_complete])

 #get number of hqmq bins 
 #added to avoid error if empty hqmq directory is created due to FS issues
 if os.path.isdir(hqmq_bins_dir):
  num_hqmq = len(os.listdir(hqmq_bins_dir))
 else:
  num_hqmq = 0

 if num_hqmq >=1 :

  #optional for NMDC
  if(lineage_sdb or lineage_tsv):
   if (checkpoint == "yes") and os.path.isfile(phylodist_complete): pass
   else:
    #img phylodist
    log.info('..run img phylodist on hq,mq bins')
    if lineage_sdb : mbin_lineage.phylodist(lineage_sdb, hqmq_bins_dir, sdb_name, log)
    elif lineage_tsv : mbin_lineage.phylodist_tsv(lineage_tsv, hqmq_bins_dir, sdb_name, log)
    #add checkpoint file
    if (checkpoint == "yes") : subprocess.check_call(['touch',phylodist_complete])

  if (checkpoint == "yes") and os.path.isfile(gtdbtk_complete): pass
  else:
   #gtdb-tk lineage
   log.info('..run gtdb-tk on hq,mq bins')
   mbin_lineage.gtdbtk(hqmq_bins_dir, gtdbtk_dir, sdb_name, numcores, pplacer_cores, log)
   
   #add checkpoint file
   if (checkpoint == "yes"): subprocess.check_call(['touch',gtdbtk_complete])

  #added for cromwell : tar hqmq bins dir
  log.info('..compressing hqmq bins dir')
  shutil.make_archive(hqmq_bins_dir, 'gztar',root_dir=os.getcwd(),base_dir=os.path.basename(hqmq_bins_dir))
 
 else:
  #touch file to avoid pickup
  subprocess.check_call(['touch',no_load_fn])  
  log.info('No HQ/MQ bins. Created flag file to avoid pickup:'+ no_load_fn)

 #carry out euk identification on lq bins if requested
 if eukcc_db:
  if len(os.listdir(filtered_bins_dir)) < 1 : 
   log.info("No LQ bins found. Will skip euk identification.")
  elif (checkpoint == "yes") and os.path.isfile(eukcc_complete): 
   pass
  else:
   log.info(".. running euk identification using eukcc on low quality bins.")
   #run eukcc plus tax lineage conversion
   try:
    mbin_ebip.run(filtered_bins_dir, eukcc_db, numcores, log)
   except subprocess.CalledProcessError as e:
    log.info(f"Error during euk identification: {e}. Skipping this step.")
   #add checkpoint file
   if (checkpoint == "yes") : subprocess.check_call(['touch',eukcc_complete])

 #added for cromwell : tar filtered metatbat bins dir
 #required to retain LQ bins for standalone euk identification
 if len(os.listdir(filtered_bins_dir)) > 1 :
  log.info('..compressing filtered/non-filtered metabat bins dir')
  shutil.make_archive(filtered_bins_dir, 'gztar',root_dir=os.getcwd(),base_dir=os.path.basename(filtered_bins_dir))

 #write flag file
 subprocess.check_call(['touch', complete_fn])
 log.info('Completion flag file:' + complete_fn)

if __name__ == '__main__':
 parser = argparse.ArgumentParser(
  prog= "mbin.py" ,
  description='Metagenome binning pipeline for IMG. Author: Neha J. Varghese.', 
  epilog="NOTE: The environment variables required are : GTDBTK_DATA_PATH=<path> and CHECKM_DATA_PATH=<path>")
 
 parser.add_argument("--threads", type=int, default=1,  help = "Num of threads/cores (default:1)")
 parser.add_argument("--pthreads", type=int, default=1,  help = "Number of pplacer threads (default:1)")
 parser.add_argument("--combined", type=str, default= "no",  help = "(yes/no) that a mutli sam dir was provided as --aln argument (default:no)")
 parser.add_argument("--sortfna", type=str, default="no", help = "(yes/no) Sort provided contigs file (default: no, always no for combined)")
 parser.add_argument("--sortaln", type=str, default="no", help = "(yes/no) Sort provided alignment file using samtools (default: no, always no for combined)")
 parser.add_argument("--checkpoint", type=str, default="no", help = "(yes/no) Generates checkpoint files and indicates to resume from checkpoint (default: no)")
 #optional for NMDC
 parser.add_argument("--map", type=str, help= "MAP file containing mapping of contig headers between SAM and FNA (will skip contig name mapping if absent)")
 parser.add_argument("--lin", type=str, help = "IMG lineage SQLITE DB for taxon (tsv OR sdb are required for filtering and IMG bin lineage prediction)")
 parser.add_argument("--lintsv", type=str, help = "IMG lineage TSV file taxon (tsv OR sdb are required for filtering and IMG bin lineage prediction)")
 #optional for euk bin identification
 parser.add_argument("--eukccdb", type=str, help = "Path to EukCC database. (Optional arg to run euk identification on low quality bins)") 

 requiredNamed = parser.add_argument_group('Required arguments')
 requiredNamed.add_argument("-f", "--fna", type=str, help= "Contigs fasta file", required=True)
 requiredNamed.add_argument("-a", "--aln", type=str, help= "Metagenome alignment file in BAM/SAM format", required=True)
 requiredNamed.add_argument("-g", "--gff", type=str, help = "GFF file from IMG annotation pipeline",required=True)
 
 args = parser.parse_args()
 log = logfile.startlog('mbin-docker')

 run(args.fna, args.aln, args.map, args.gff, args.lin, args.lintsv, args.threads, args.pthreads, args.combined, args.sortfna, args.sortaln, args.checkpoint, args.eukccdb)